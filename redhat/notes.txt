redhat

[user@host ~]$  			[root@host ~]#

The command is the name of the program to run. It might be followed by one or more options, which adjust the behavior of the command or what it does. Options normally start with one or two dashes (-a or --all, for example) to distinguish them from arguments. Commands might also be followed by one or more arguments, which often indicate a target that the command should operate on
For example, in the usermod -L user01 string, usermod is the command, -L is the option, and user01 is the argument

ssh
An alternative way to authenticate to a remote machine without entering a password is through public key authentication

The ssh command -i option is used to specify the user's private key file, which is mylab.pem. The matching public key is already set up as an authorized key in the remoteuser account.

[user@host ~]$ ssh -i mylab.pem remoteuser@remotehost  you can use the chmod 600 mylab.pem command to ensure that only the owner can read the file


Shortcut	Description
Ctrl+A	Jump to the beginning of the command line.
Ctrl+E	Jump to the end of the command line.
Ctrl+U	Clear from the cursor to the beginning of the command line.
Ctrl+K	Clear from the cursor to the end of the command line.
Ctrl+LeftArrow	Jump to the beginning of the previous word on the command line.
Ctrl+RightArrow	Jump to the end of the next word on the command line.
Ctrl+R	Search the history list of commands for a pattern.
55TURNK3y

date +%R saati gosterir
date +%x tarihi gosterir

The less command displays one page of a file at a time The head and tail commands display the beginning and the end of a file-n option to specify a different number of lines.The wc command counts lines, words, and characters in a file.-l, -w, or -c options to display only the given number of lines, words, or characters,  line words and chareCTER sira ile gelir.



To write one command in more than one line, use a backslash character (\),

The !number command expands from history command

Moving the Cursor:

Ctrl + A: Move to the beginning of the line.
Ctrl + E: Move to the end of the line.
Ctrl + U: Delete from the cursor to the beginning of the line.
Ctrl + K: Delete from the cursor to the end of the line.
Deleting and Cutting:

Ctrl + W: Delete the word before the cursor.
Ctrl + Y: Paste the last deleted text.
Manipulating Words:

Alt + Backspace or Ctrl + W: Delete the word before the cursor.
Alt + D: Delete the word after the cursor.
History Navigation:

Ctrl + R: Search the command history interactively.
!!: Repeat the last command.
!n: Repeat the nth command in the history.
Other Handy Commands:

Ctrl + C: Cancel the current command.
Ctrl + L: Clear the screen.
Ctrl + D: Exit the shell (or send an EOF if the line is empty).
!! en son girielen komutu tekrar yazar

/dev	Special device files that the system uses to access hardware.
/etc	System-specific configuration files.
/home	Home directory, where regular users store their data and configuration files.
/root	Home directory for the administrative superuser, root.
/run	Runtime data for processes that started since the last boot. This data includes process ID files and lock files. The contents of this directory are re-created on reboot. This directory consolidates the /var/run and /var/lock directories from earlier versions of Red Hat Enterprise Linux.
/tmp	A world-writable space for temporary files. Files that are not accessed, changed, or modified for 10 days are deleted from this directory automatically. The /var/tmp directory is also a temporary directory, in which files that are not accessed, changed, or modified in more than 30 days are deleted automatically.
/usr	Installed software, shared libraries, including files, and read-only program data. Significant subdirectories in the /usr directory include the following commands:
/usr/bin: User commands

/usr/sbin: System administration commands

/usr/local: Locally customized software

/var	System-specific variable data should persist between boots. Files that dynamically change, such as databases, cache directories, log files, printer-spooled documents, and website content, might be found under /var.

The touch command updates the time stamp of a file to the current date and time without otherwise modifying it.

cd - once ki komut sadece cd home a gider


You can create two types of links: a hard link, or a symbolic link (sometimes called a soft link).The new hard link acts exactly like the original file name. After the link is created, you cannot tell the difference between the new hard link and the original name of the file.You can determine whether a file has multiple hard links by using the ls -l command.You can use the "ln" command to create a hard link (another file name) that points to an existing file. The command needs at least two arguments: a path to the existing file, and the path to the hard link that you want to create.--- ln newfile.txt /tmp/newfile-hlink2.txt    To determine whether two files are hard linked, use the ls command -i option to list each file's inode number. If the files are on the same file system and their inode numbers are the same, then the files are hard links that point to the same data file content.Even if the original file is deleted, you can still access the contents of the file provided that at least one other hard link exists.Second, you can use hard links only if both files are on the same file system.

Create Symbolic Links
The ln command -s option creates a symbolic link, which is also called a "soft link". A symbolic link is not a regular file, but a special type of file that points to an existing file or directory. symbolic links can link two files on different file systems. Symbolic links can point to a directory or special file, not just to a regular file.



Pattern	Matches
*	Any string of zero or more characters
?	Any single character
[abc…​]	Any one character in the enclosed class (between the square brackets)
[!abc…​]	Any one character not in the enclosed class
[^abc…​]	Any one character not in the enclosed class
[[:alpha:]]	Any alphabetic character
[[:lower:]]	Any lowercase character
[[:upper:]]	Any uppercase character
[[:alnum:]]	Any alphabetic character or digit
[[:punct:]]	Any printable character that is not a space or alphanumeric
[[:digit:]]	Any single digit from 0 to 9
[[:space:]]	Any single white space character, which might include tabs, newlines, carriage returns, form feeds, or spaces


When the original regular file is deleted, the symbolic link still points to the file but the target is gone

[user@host glob]$ echo {Sunday,Monday,Tuesday,Wednesday}.log
Sunday.log Monday.log Tuesday.log Wednesday.log
[user@host glob]$ echo file{1..3}.txt
file1.txt file2.txt file3.txt
[user@host glob]$ echo file{a..c}.txt
filea.txt fileb.txt filec.txt
[user@host glob]$ echo file{a,b}{1,2}.txt
filea1.txt filea2.txt fileb1.txt fileb2.txt
[user@host glob]$ echo file{a{1,2},b,c}.txt
filea1.txt filea2.txt fileb.txt filec.txt


variables
[user@host ~]$ USERNAME=operator
[user@host ~]$ echo $USERNAME
operator
To prevent mistakes due to other shell expansions, you can put the name of the variable in curly braces, for example ${VARIABLENAME}.

[user@host ~]$ USERNAME=operator
[user@host ~]$ echo ${USERNAME}
operator
Variable names can contain only letters (uppercase and lowercase), numbers, and underscores. Variable names are case-sensitive and cannot start with a number.

echo my directory is $(pwd)
my directory is /root/yusuf/redhat


The backslash (\) is an escape character in the Bash shell. It protects the following character from expansion.

[!b]*  b olmayan demek

*[[:digit:]]*    matches only file names that contain a number?


Use the man command -k option (equivalent to the apropos command) to search for a keyword in man page titles and descriptions

The man command -K (uppercase) option searches for the keyword in the full-text page, not only in the titles and descriptions. A full-text search uses greater system resources and takes more time. The /usr/share/man directory contains all man pages



stdin 0
stdout 1
stderr 2
 If you redirect stdout to a file and the file does not exist, then the file is created.
2> /dev/null     displays output to a terminal and discards all error messages

VIM
A v keystroke enters visual mode, where multiple characters might be selected for text manipulation. Use Shift+V for multiline and Ctrl+V for block selection. To exit the visual mode, use the v, Shift+V, or Ctrl+V keystrokesIf you are unsure which mode Vim is using, then press Esc a few times to get back into command mode.

The u key undoes the most recent edit.

The x key deletes a single character.
hang back, jump down, kick up, leap forward.

Change the Shell Environment
You can use the set command to list all shell variables that are currently set.
For example, the HISTFILE, HISTFILESIZE, and HISTTIMEFORMAT shell variables affect the shell history and the history command
If a shell variable is not an environment variable, then only the shell can use it. However, if a shell variable is an environment variable, then the shell and any programs that run from that shell can use the variable.

You can assign any variable that is defined in the shell as an environment variable by marking it for export with the export command.
[user@host ~]$ EDITOR=vim
[user@host ~]$ export EDITOR
veya
[user@host ~]$ export EDITOR=vim  boyle tek satirda da olur

Another important environment variable is PATH. The PATH variable contains a list of colon-separated directories that contain programs:
[user@host ~]$ echo $PATH
/home/user/.local/bin:/home/user/bin:/usr/share/Modules/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin

When you run a command such as the ls command, the shell looks for the ls executable file in each of those directories in order, and runs the first matching file that it finds. (On a typical system, this file is /usr/bin/ls.)


Set Variables Automatically
When Bash starts, several text files run with shell commands that initialize the shell environment. To set shell or environment variables automatically when your shell starts, you can edit these Bash startup scripts.



For interactive login shells, the /etc/profile and ~/.bash_profile files configure the Bash environment. The /etc/profile and ~/.bash_profile files also source the /etc/bashrc and ~/.bashrc files respectively. For interactive non-login shells, only the /etc/bashrc and ~/.bashrc files configure the Bash environment. Whereas the /etc/profile and /etc/bashrc files apply to the whole system, the ~/.bash_profile and ~/.bashrc files are user-specific. Non-interactive shells invoke any files that the BASH_ENV variable defines. This variable is not defined by default.

To create a variable that is available to all of your interactive shells, edit the ~/.bashrc file. To apply a variable only once after the user logs in, define it in the ~/.bash_profile file.

ornek>
# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
        . ~/.bashrc
fi

# User specific environment and startup programs
export EDITOR=nano  bunu eklezerek editor nano olur


[user@host ~]$ alias hello='echo "Hello, this is a long string."'
[user@host ~]$ hello
Hello, this is a long string.

[user@host ~]$ echo $file1
/tmp/tmp.z9pXW0HqcC
[user@host ~]$ unset file1
[user@host ~]$ echo $file1


To unexport a variable without unsetting it, use the export -n command:
[user@host ~]$ export -n PS1
To unset an alias, use the unalias command:
[user@host ~]$ unalias hello

Manage Local Users and Groups


https://rol.redhat.com/rol/app/courses/rh124-9.0/pages/ch06
